<?php

namespace Articulate\Tests\Attributes;

use Articulate\Attributes\Indexes\Index;
use Articulate\Attributes\Property;
use PHPUnit\Framework\TestCase;

class IndexAttributeTest extends TestCase
{
    public function testIndexAttributeDefaultConstructor(): void
    {
        $index = new Index(['field1', 'field2']);

        $this->assertEquals(['field1', 'field2'], $index->fields);
        $this->assertFalse($index->unique);
        $this->assertNull($index->name);
        $this->assertFalse($index->concurrent);
        $this->assertEquals([], $index->columns);
    }

    public function testIndexAttributeWithAllParameters(): void
    {
        $index = new Index(
            fields: ['user_id', 'email'],
            unique: true,
            name: 'user_email_idx',
            concurrent: true
        );

        $this->assertEquals(['user_id', 'email'], $index->fields);
        $this->assertTrue($index->unique);
        $this->assertEquals('user_email_idx', $index->name);
        $this->assertTrue($index->concurrent);
        $this->assertEquals([], $index->columns);
    }

    public function testIndexAttributeWithUniqueIndex(): void
    {
        $index = new Index(['username'], unique: true);

        $this->assertEquals(['username'], $index->fields);
        $this->assertTrue($index->unique);
        $this->assertNull($index->name);
        $this->assertFalse($index->concurrent);
    }

    public function testIndexAttributeWithCustomName(): void
    {
        $index = new Index(['created_at', 'updated_at'], name: 'timestamp_idx');

        $this->assertEquals(['created_at', 'updated_at'], $index->fields);
        $this->assertFalse($index->unique);
        $this->assertEquals('timestamp_idx', $index->name);
        $this->assertFalse($index->concurrent);
    }

    public function testIndexAttributeWithConcurrent(): void
    {
        $index = new Index(['status'], concurrent: true);

        $this->assertEquals(['status'], $index->fields);
        $this->assertFalse($index->unique);
        $this->assertNull($index->name);
        $this->assertTrue($index->concurrent);
    }

    public function testIndexAttributeSingleField(): void
    {
        $index = new Index(['id']);

        $this->assertEquals(['id'], $index->fields);
        $this->assertFalse($index->unique);
        $this->assertNull($index->name);
        $this->assertFalse($index->concurrent);
    }

    public function testIndexAttributeMultipleFields(): void
    {
        $fields = ['user_id', 'post_id', 'created_at'];
        $index = new Index($fields);

        $this->assertEquals($fields, $index->fields);
        $this->assertFalse($index->unique);
        $this->assertNull($index->name);
        $this->assertFalse($index->concurrent);
    }

    public function testGetNameWithCustomName(): void
    {
        $index = new Index(['field'], name: 'custom_index_name');

        $this->assertEquals('custom_index_name', $index->getName());
    }

    public function testGetNameAutoGenerated(): void
    {
        $index = new Index(['user_id', 'email']);
        // Manually set columns since resolveColumns is not called
        $index->columns = ['user_id', 'email'];

        $this->assertEquals('user_id_email_idx', $index->getName());
    }

    public function testGetNameAutoGeneratedSingleField(): void
    {
        $index = new Index(['username']);
        $index->columns = ['username'];

        $this->assertEquals('username_idx', $index->getName());
    }

    public function testGetNameAutoGeneratedLongName(): void
    {
        // Create a very long field name that would exceed MySQL's 64 character limit
        $longField = str_repeat('a', 61); // 61 + 4 = 65 chars total
        $index = new Index([$longField]);
        $index->columns = [$longField];

        $generatedName = $index->getName();

        // Should be a hash since it's too long
        $this->assertNotEquals($longField . '_idx', $generatedName);
        $this->assertEquals(32, strlen($generatedName)); // MD5 hash length
    }

    public function testGetNameAutoGeneratedExactly64Chars(): void
    {
        // Create a name that would be exactly 64 characters with _idx suffix
        $fieldName = str_repeat('a', 60); // 60 + 4 = 64 chars with _idx
        $index = new Index([$fieldName]);
        $index->columns = [$fieldName];

        $generatedName = $index->getName();

        // Should not be truncated since it's exactly at the limit
        $this->assertEquals($fieldName . '_idx', $generatedName);
        $this->assertEquals(64, strlen($generatedName));
    }

    public function testGetNameAutoGeneratedOver64Chars(): void
    {
        // Create a name that would exceed 64 characters
        $fieldName = str_repeat('a', 61); // 61 + 4 = 65 chars with _idx
        $index = new Index([$fieldName]);
        $index->columns = [$fieldName];

        $generatedName = $index->getName();

        // Should be hashed since it's over the limit
        $this->assertNotEquals($fieldName . '_idx', $generatedName);
        $this->assertEquals(32, strlen($generatedName)); // MD5 hash length
    }

    public function testResolveColumnsMethodExists(): void
    {
        $index = new Index(['field1']);

        // The method exists and can be called
        $this->assertTrue(method_exists($index, 'resolveColumns'));
        $this->assertIsCallable([$index, 'resolveColumns']);
    }

    public function testIndexAttributeIsRepeatable(): void
    {
        // Test that the attribute is marked as repeatable (IS_REPEATABLE flag)
        // This is verified by the fact that the class can have multiple Index attributes
        $reflection = new \ReflectionClass(Index::class);
        $attributes = $reflection->getAttributes(\Attribute::class);

        $this->assertCount(1, $attributes);

        $attribute = $attributes[0]->newInstance();
        $this->assertEquals(\Attribute::TARGET_CLASS | \Attribute::IS_REPEATABLE, $attribute->flags);
    }

    public function testIndexAttributeTarget(): void
    {
        // Verify the attribute targets classes
        $reflection = new \ReflectionClass(Index::class);
        $attributes = $reflection->getAttributes(\Attribute::class);

        $this->assertCount(1, $attributes);

        $attribute = $attributes[0]->newInstance();
        $this->assertTrue(($attribute->flags & \Attribute::TARGET_CLASS) !== 0);
    }
}